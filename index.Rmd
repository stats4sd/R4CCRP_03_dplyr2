---
title: "Manipulating Data using dplyr: part 2"
output: 
  learnr::tutorial:
    progressive: true
    allow_skip: true
    df_print: paged
runtime: shiny_prerendered
description: >
  Learn to manipulate data with the package dplyr.
---


```{r setup, include=FALSE}
library(learnr)
library(dplyr)
tutorial_options(exercise.timelimit = 10)
options(max.print=50)
BeanSurvey<-readRDS("bean_survey.RDS")[,-1]
```


## Combining manipulations

![](https://youtu.be/skdI9iIysm0)

We've now learnt to use most of the core functions of dplyr. But their use is greatly limited by the fact that we still don't know how to combine them together. 

Because as explained in the video, if we don't store the results of our commands, there is no way to re-use them. This is actually true for the great majority of R commands, not just those involving the core functions of dplyr. So to perform a sequence of manipulations, we need to either:

- store the result of each manipulation as a data frame, to then make it the first argument of the next function.
- combine all the manipulations we want to perform into one single command using the **pipe operator**.

You already know everything there is to know to perform a sequence of manipulations via the first option.
For example, if we wanted to calculate a couple of summary statistics on the household living in the Lwala village, we could do the following:

```{r sequence_1, exercise = TRUE}
BeanSurvey_Lwala <- filter(BeanSurvey, VILLAGE=="Lwala")
summarise(BeanSurvey_Lwala, households=n(), mean_land=mean(LANDAREA), grow_beans= sum(BEANS=="Yes"))
```
First we use `filter()` to keep only the households of "Lwala". We store the result as a new object, called "BeanSurvey_Lwala". Then we use the `summarise()` command, but with the newly created object as the first argument instead of the full imdb dataset.



**Question: change the command to get summaries for the households in Kimbugu rather than Lwala. Give a sensible name to the intermediary data frame**

```{r sequence_2, exercise = TRUE}
BeanSurvey_Lwala <- filter(BeanSurvey, VILLAGE=="Lwala")
summarise(BeanSurvey_Lwala, households=n(), mean_land=mean(LANDAREA), grow_beans= sum(BEANS=="Yes"))
```

```{r sequence_2-solution}
BeanSurvey_Kimbugu <- filter(BeanSurvey, VILLAGE=="Kimbugu")
summarise(BeanSurvey_Kimbugu, households=n(), mean_land=mean(LANDAREA), grow_beans= sum(BEANS=="Yes"))
```

But what if there were say, 20 villages? Doing this for each village would be very time consuming. Don't worry, there is a much better approach, using `group_by()`, the last core function of the package dplyr.


## group_by()

`group_by()` tells R to separate a dataset into groups, based on the values of a column. All the subsequent operations performed on the resulting "grouped" dataset are applied to each group rather than to the whole dataset. For the syntax, we indicate the dataset first, as usual, and then we indicate the column whose values will define our groups. Let's group our dataset by village

```{r group_1, exercise = TRUE}
group_by(BeanSurvey, VILLAGE)

```
It looks like nothing happened to our dataset, but it's just because the grouping is invisible. We need to apply another function to see the effect of `group_by()`. Let's store our grouped data frame in an object called say, "BeanSurvey_ByVillage", and use this object as the first argument of the function `summarise()`

```{r group_2, exercise = TRUE}
BeanSurvey_ByVillage <- group_by(BeanSurvey, VILLAGE)
summarise(BeanSurvey_ByVillage, households=n(), mean_land=mean(LANDAREA), grow_beans= sum(BEANS=="Yes"))
```

The effect of `group_by()` on the result of `summarise()` is very intuitive. We obtain the calculated summaries for each of the groups defined by the function `group_by()`. At first, it might be slightly less obvious that `group_by()` is also very useful in combination with `filter()` or `mutate()`. But consider the case where we would like to retrieve for each village the information of the household that has harvested the highest quantity of beans in long rain season. With filter, we can easily get the household that has harvested the highest quantity of beans during the long rain season in the full dataset:
```{r group_4, exercise = TRUE}
filter(BeanSurvey, BEANSHARVESTED_LR==max(BEANSHARVESTED_LR, na.rm=TRUE))

```
Note that there is one value that is missing in the column `BEANSHARVESTED_LR`, so we need to use `na.rm=TRUE` like for the function `mean()` earlier.

But the highest production of beans during long rain season comes from a household in *Kimbugu*. In Lwala, the highest production is smaller than that and so it is not captured by our filter function.

Using `group_by()` first, and *then* `filter()` would restrict the scope of `BEANSHARVESTED_LR==max(BEANSHARVESTED_LR, na.rm=TRUE)` to each village, and so if a household has the highest production in this village, filter will retrieve it.

```{r group_4a, exercise = TRUE}
BeanSurvey_ByVillage <- group_by(BeanSurvey, VILLAGE)
filter(BeanSurvey_ByVillage, BEANSHARVESTED_LR==max(BEANSHARVESTED_LR, na.rm=TRUE))

```


**Question: Calculate the number of household and average land area for each type of household composition (column HHTYPE). What do we seem to see?**
```{r group_4b, exercise = TRUE}


```

```{r group_4b-solution}
BeanSurvey_ByHHType<-group_by(BeanSurvey, HHTYPE)
summarise(BeanSurvey_ByHHType, households=n(), averageArea=mean(LANDAREA))
# There are two main household composition in the dataset: Female headed, no husband (13 households), and Male headed one wife (27 households)
# The households of the second type seem to have the largest lands in average

```

But what if we wanted to perform more than two manipulations? What if we wanted to keep only those household who grow beans and calculate for each village the average yield per acre? It doesn't sound too complicated, but we still need to use four functions to do that.

- filter to get rid of the households that don't grow beans
= mutate to calculate the yield per acre of each household
- group_by to group our data by village
- summarise to calculate the average yield per acre by village.

And after each manipulation, we would need to save the result as a new data frame that will be used as the input for the next function.

This would do the job:

```{r group_5, exercise = TRUE}
BeanSurvey_filtered <- filter(BeanSurvey, BEANS=="Yes")
BeanSurvey_mutated <- mutate(BeanSurvey_filtered, yield_per_acre = (BEANSHARVESTED_LR + BEANSHARVESTED_SR)/LANDAREA)
BeanSurvey_grouped_by<- group_by(BeanSurvey_mutated, VILLAGE)
summarise(BeanSurvey_grouped_by, households=n(), avg_yield_per_acre=mean(yield_per_acre, na.rm=TRUE))

```
The code above starts to be quite messy, with lots of intermediary data frames that we are not really interested in. One thing you may suggest to simplify our set of commands is to have only one intermediary data frame, that we overwrite. Something like
```{r group_7, exercise = TRUE}
temp_data <- filter(BeanSurvey, BEANS=="Yes")
temp_data <- mutate(temp_data, yield_per_acre = (BEANSHARVESTED_LR + BEANSHARVESTED_SR)/LANDAREA)
temp_data <- group_by(temp_data, VILLAGE)
summarise(temp_data, households=n(), avg_yield_per_acre=mean(yield_per_acre, na.rm=TRUE))

```

It looks slightly simpler maybe, and show you that when creating objects with `<-`, it makes no difference whether the name of the object is new or not. If it is not new, R will just overwrite the old object.

But this way of overwriting objects over and over is definitely not good practice, as in some situations you may end up loosing valuable data. We don't need to use such approach though. We can make our command much more clean and readable if we use the pipe operator.


## pipe %>%

The symbol used for the pipe operator in R is `%>%`, that is a symbol greater than `>` surrounded by two percentages `%`. This operator is extremely useful because it makes it possible to perform a sequence of data manipulations using dplyr functions, without having to create any intermediate data frame. This is due to the consistent syntax of these dplyr functions, and in particular, the fact that their first argument is always the data fame that we want to manipulate.

Because what the pipe operator does is to tell R

> take what's on my left, and make it the first argument of the next function on my right or below me

So if in the command `thing1 %>% thing2`, `thing1` is a data frame and `thing2` is a dplyr function, the pipe operator will ask R to make the data frame the first argument of the dplyr function. And R will happily perform the corresponding manipulation on the data frame since it results in a valid command.

```{r pipe_1, exercise = TRUE}
BeanSurvey %>% filter(BEANS=="Yes")

```

In the above commands, the pipe operator asks R to take what's on its left - the data frame `BeanSurvey` - and to make it the first argument of what's on its right - the function `filter()`.
The command is therefore equivalent to

```{r pipe_1b, exercise = TRUE}
filter(BeanSurvey, BEANS=="Yes")

```

Instead of placing the function filter to the right of the pipe, we can, and usually should place it below the pipe, with a little indentation, similar to what you do with the `+` in ggplot2. It's good practice for readability, and it doesn't change anything. R will see the pipe and look for the next command. This command happens to be below the pipe rather than on its right.

```{r pipe_2, exercise = TRUE}
BeanSurvey %>% 
  filter(BEANS=="Yes")

```
 

What is great with pipes is that the *what's on my left* can well be a command itself, if the result of the command is a data frame. So we can redo the last commands of the previous section, using pipes.


Our commands were
```{r pipe_2b, exercise = TRUE}
BeanSurvey_filtered <- filter(BeanSurvey, BEANS=="Yes")
BeanSurvey_mutated <- mutate(BeanSurvey_filtered, yield_per_acre = (BEANSHARVESTED_LR + BEANSHARVESTED_SR)/LANDAREA)
BeanSurvey_grouped_by<- group_by(BeanSurvey_mutated, VILLAGE)
summarise(BeanSurvey_grouped_by, households=n(), avg_yield_per_acre=mean(yield_per_acre, na.rm=TRUE))

```


Using pipes it becomes:

```{r pipe_3, exercise = TRUE}
BeanSurvey %>% 
  filter(BEANS=="Yes") %>%
    mutate(yield_per_acre = (BEANSHARVESTED_LR + BEANSHARVESTED_SR)/LANDAREA) %>%
      group_by(VILLAGE) %>%
        summarise(households=n(), avg_yield_per_acre=mean(yield_per_acre, na.rm=TRUE))

```

We start with the dataset `BeanSurvey`. The pipe next to it will make it the first argument of the function `filter()` that follows. The next pipe makes the resulting command the first argument of the function `mutate()`. The next pipe takes the result of all of this and make it the first argument of the next function, which is `group_by()`. And the last pipe makes the resulting data frame, the first argument of the function `summarise()`. Here we go. We have a neat and concise command! Note that when using pipes, the output from the previous line always takes the place of the ‘data’ argument. So when using the commands with the pipes, we skip straight to the second argument.


And that's where things start to be very interesting. Because with pipes, it is not a pain anymore to perform a long sequence of manipulations. So we can really start to have fun!

Also note that the order of our commands matter. Try and see if you can understand what happens when you change the order of these commands.




Something we can also do is continue our commands with functions that are not part of dplyr, because pipe is so popular that lots of the most recent packages provide functions that are compatible with pipes. And as said in the video, `ggplot()` is compatible with pipes, since its first argument is the dataframe used to make the plot.



Let's try and make a little scatter plot showing the average rating (on the y axis) of the most voted on movie released per year, where year is on the x axis. How are we going to do that?

Well we know that we're only interested in movies, so a safe first step would be to filter out the other entries using filter:



As you may start to see, once you get familiar with the pipe operator and all the functions we've seen so far, it quickly becomes pretty easy to make long sequences of manipulations.



**Question: Determine for each type of entry, which is the best rated title using pipes?**

```{r pipe_4, exercise = TRUE}


```
```{r pipe_4-solution}
imdb %>%
  group_by(type) %>%
    filter(averageRating==max(averageRating))

```



Of course, if we want to store the result of our full command into a dataframe object for later use, we can do that.



## Appendix: Useful reference links  


The official dplyr documentation: <a href="https://dplyr.tidyverse.org/" target="_blank">https://dplyr.tidyverse.org/</a> 

dplyr CheatSheet:<a href="https://github.com/rstudio/cheatsheets/blob/master/data-transformation.pdf" target="_blank">https://github.com/rstudio/cheatsheets/blob/master/data-transformation.pdf   </a>  

Data Manipulation Tools - Rstudio video:
<a href="https://www.youtube.com/watch?v=Zc_ufg4uW4U" target="_blank">dplyr -- Pt 3 Intro to the Grammar of Data Manipulation with R   </a> 

Some documentation on subsetting r-objects using base-R: <a href="https://bookdown.org/rdpeng/rprogdatascience/subsetting-r-objects.html" target="_blank">https://bookdown.org/rdpeng/rprogdatascience/subsetting-r-objects.html </a> 


